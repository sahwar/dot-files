" Title: vimrc
" Author: Thiago de Arruda (github.com/tarruda)
" Description:
"   This file initializes my vim customizations/addons.  It was tested on vim
"   7.3 compiled with most features.  A lot here was taken from this vimrc:
"   https://bitbucket.org/sjl/dotfiles/src/tip/vim/vimrc

" Basic initialization {{{
"
if !exists('g:vimrc_done_basic_init')
  let g:is_windows = has('win32') || has('win64')
  " Little hack to set the $MYVIMRC from the $VIMINIT in the case it was used to 
  " initialize vim.
  let s:default_vimrc = 1
  if empty($MYVIMRC)
    let $MYVIMRC = substitute($VIMINIT, "^source ", "", "g")
    let s:default_vimrc = 0
  endif
  " Extract the directory from $MYVIMRC
  if g:is_windows
    let g:rc_dir = strpart($MYVIMRC, 0, strridx($MYVIMRC, '\'))
  else
    let g:rc_dir = strpart($MYVIMRC, 0, strridx($MYVIMRC, '/'))
  endif
  if s:default_vimrc
    " Set .vim as the rc_dir
    let g:rc_dir = g:rc_dir.'/.vim'
  endif
  let g:vam_plugins_dir = g:rc_dir.'/addons'
  let &runtimepath = g:rc_dir.','.g:vam_plugins_dir.'/vim-addon-manager,'.$VIMRUNTIME
  let g:has_python = has('python') || has('python3')
endif

" }}}
" Global settings {{{
"
set nocompatible
let mapleader = ","
set backspace=indent,eol,start " backspace over everything in insert mode
set nobackup " no need for backup files(use undo files instead)
set undofile " create '.<FILENAME>.un~' for persiting undo history
set dir=.,/tmp " swap files storage, first try in the cwd then in /tmp
set undodir=. " undo files storage, only allow the same directory
set history=500 " 500 lines of command-line history
set ruler " display cursor position at bottom
set mouse=a " enable terminal mouse extensions
if &term =~ 'tmux' " requires my custom terminfo file
  set ttymouse=xterm2 " integrate mouse extensions with tmux
  set ttyfast " normally this is only set for certain known terminals
endi
set noerrorbells visualbell t_vb= " disable annoying terminal sounds
set encoding=utf-8 " universal text encoding, compatible with ascii
set list
if has('win32unix') && ! has('gui_running') " cygwin on terminal
  " cygwin's urxvt seems to have trouble displaying some unicode chars
  set listchars=tab:▸\ ,
else
  set listchars=tab:▸\ ,extends:❯,precedes:❮ " ,eol:¬
  set showbreak=↪
  set fillchars=diff:⣿,vert:│
endif
set showcmd " display incomplete commands
set completeopt=menu,menuone,longest " disable preview scratch window
set complete=.,w,b,u,t " h: 'complete'
set pumheight=15 " limit completion menu height
set nonumber " don't display line numbers on the left
set relativenumber " shows relative line numbers for easy motions
set splitbelow " put horizontal splits below 
set splitright " put vertical splits to the right
set expandtab " expand tabs into spaces
set softtabstop=2 " number of spaces used with tab/bs
set tabstop=2 " display tabs with the width of two spaces
set shiftwidth=2 " indent with two spaces 
set modelines=0 " running code in comments is not cool
set ignorecase " ignore case when searching
set smartcase " disable 'ignorecase' if search pattern has uppercase characters
set incsearch " highlight matches while typing search pattern
set hlsearch " highlight previous search matches
set showmatch " briefly jump to the matching bracket on insert
set matchtime=2 " time in decisecons to jump back from matching bracket 
set textwidth=80 " number of character allowed in a line
set wrap " automatically wrap text when 'textwidth' is reached
set foldmethod=indent " by default, fold using indentation
set nofoldenable " don't fold by default
set foldlevel=0 " if fold everything if 'foldenable' is set
set foldnestmax=10 " maximum fold depth
set synmaxcol=500 " maximum length to apply syntax highlighting
set timeout " enable timeout of key codes and mappings(the default)
set timeoutlen=3000 " big timeout for key sequences
set ttimeoutlen=10 " small timeout for key sequences since these will be normally scripted
set clipboard= " disable automatic clipboard integration
syntax on " enable syntax highlighting
filetype plugin indent on " enable file-specific plugins/settings
set backupskip=/tmp/*,/private/tmp/* " make it possible to use vim to edit crontab
augroup global_settings
  au!
  au VimResized * :wincmd = " resize windows when vim is resized 
  " return to the same line when file is reopened
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END
" if available, store temporary files in shared memory
if isdirectory('/run/shm')
  let $TMPDIR = '/run/shm'
elseif isdirectory('/dev/shm')
  let $TMPDIR = '/dev/shm'
endif
" }}}
" Terminal keycode sequences {{{
if ! has('gui_running')
  " this is used to represent ctrl+tab in terminal vim
  :set <f20>=[34~
endif
if &term == 'tmux'
  :set <up>=[A
  :set <down>=[B
  :set <right>=[C
  :set <left>=[D

  :set <a-y>=y
  :set <a-d>=d
  " Prefix used by tmux to send 'special commands' to vim. I use this so there's
  " no possibility of tmux accidentally hitting my own mappings. Think of it as
  " a namespace used for tmux-related commands
  :set <f37>=tmux
elseif &term =~ 'rxvt-unicode' || &term =~ 'xterm'
  " with urxvt configured to use xterm control/alt sequences
  " this should normalize vim/gvim mappings
  :set <a-k>=k
  :set <a-j>=j
  :set <a-l>=l
  :set <a-h>=h

  :set <a-d>=p
  :set <a-y>=y
  :set <a-d>=d
endif
" }}}
" Custom commands {{{
" Allows saving files which needs root permission with ':w!!'. This uses  one of
" the forms of the ':w' command, which instead of writing to a file, takes all
" lines in a range(or the whole buffer if not range is specified) and pipes as
" standard input for the command after '!'. In this case 'tee' will redirect its
" standard input(the entire buffer) to the file being edited(%)
cnoremap w!! w !sudo tee % >/dev/null
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.  Only define it when not
" defined already.
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
" }}}
" Utility functions {{{
function! GetVisualSelection()
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - 2]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

if &term == 'tmux'
  " tranparent window/pane movement
  function! TmuxMove(direction)
    " Check if we are currently focusing on a edge window.
    " To achieve that,  move to/from the requested window and
    " see if the window number changed
    let oldw = winnr()
    silent! exe 'wincmd ' . a:direction
    let neww = winnr()
    silent! exe oldw . 'wincmd'
    if oldw == neww
      " The focused window is at an edge, so ask tmux to switch panes
      if a:direction == 'j'
        call system("tmux select-pane -D")
      elseif a:direction == 'k'
        call system("tmux select-pane -U")
      elseif a:direction == 'h'
        call system("tmux select-pane -L")
      elseif a:direction == 'l'
        call system("tmux select-pane -R")
      endif
    end
  endfunction
  if executable('xclip') && $DISPLAY != ''
    " use the x11 clipboard as the main storage for shared yank data
    " tmux should also be configured to use it
    function! TmuxYank()
      call system('xclip -i -selection clipboard', @t)
    endfunction
    function! TmuxPaste()
      let @t = system('xclip -o -selection clipboard')
    endfunction
  else
    function! TmuxYank()
      " FIXME for some reason, the form 'tmux load-buffer -' will hang when used
      " with 'system()' which takes a second argument as stdin, so we have to
      " use a temporary file to load data into tmux. Fixing this it is more a
      " matter of aesthetics than peformance, because vim will also create a
      " temporary file instead of piping the data directly.
      let tmpfile = tempname()
      call writefile(split(@t, '\n'), tmpfile, 'b')
      call system('cat '.shellescape(tmpfile).' | tmux load-buffer -')
      call delete(tmpfile)
    endfunction
    function! TmuxPaste()
      let @t = system('tmux show-buffer')
    endfunction
  endif
endif
" }}}
" Mappings {{{
nnoremap <silent> <c-j> :m .+1<cr>==
nnoremap <silent> <c-k> :m .-2<cr>==
" Quickly open help in the current window
"" :view $VIMRUNTIME/doc/help.txt<cr>
nnoremap <silent> <leader>h :view +1 $VIMRUNTIME/doc/help.txt<cr>:setf help nomodifiable<cr>
" Move selections
vnoremap <silent> <c-j> :m '>+1<cr>gv=gv
vnoremap <silent> <c-k> :m '<-2<cr>gv=gv
" Disable help key
inoremap <f1> <esc>
nnoremap <f1> <esc>
vnoremap <f1> <esc>
" search/replace the word under the cursor
nnoremap <leader>z :let @z = expand("<cword>")<cr>q:i%s/\C\v<<esc>"zpa>//g<esc>hi
" Quickly toggle spell on/off
nnoremap <silent> <leader>s :set spell!<cr>
" Clear search highlight with ,c
nnoremap <silent> <leader>c :noh<cr>
" Capitalize the first word of every sentence in a selection and format it.
" Useful for quickly formatting comments. The capitalize part was taken from:
" http://societyserver.org/mbaehr/vim-tips--capitalize-the-first-word-of-every-sentence
vnoremap <silent> <leader>f :s/\v(\w)(\_[^.?!:;]*)/\u\1\2/g<cr>:noh<cr>gvgq
" quickly edit vimrc
nnoremap <leader>e :e $MYVIMRC<cr>
" quickly reload vimrc
nnoremap <leader>r :source $MYVIMRC<cr>:e<cr>
if &term == 'tmux'
  " tmux will handle the actual mappings so we just 
  nnoremap <silent> <f37>move-down :silent call TmuxMove('j')<cr>
  nnoremap <silent> <f37>move-up :silent call TmuxMove('k')<cr>
  nnoremap <silent> <f37>move-left :silent call TmuxMove('h')<cr>
  nnoremap <silent> <f37>move-right :silent call TmuxMove('l')<cr>
  inoremap <silent> <f37>move-down <esc>:silent call TmuxMove('j')<cr>
  inoremap <silent> <f37>move-up <esc>:silent call TmuxMove('k')<cr>
  inoremap <silent> <f37>move-left <esc>:silent call TmuxMove('h')<cr>
  inoremap <silent> <f37>move-right <esc>:silent call TmuxMove('l')<cr>
  vnoremap <silent> <f37>move-down <esc>:silent call TmuxMove('j')<cr>
  vnoremap <silent> <f37>move-up <esc>:silent call TmuxMove('k')<cr>
  vnoremap <silent> <f37>move-left <esc>:silent call TmuxMove('h')<cr>
  vnoremap <silent> <f37>move-right <esc>:silent call TmuxMove('l')<cr>
  nnoremap <silent> <f37>paste-tmux :call TmuxPaste()<cr>"tp
  vnoremap <silent> <f37>paste-tmux d:call TmuxPaste()<cr>h"tp
  vnoremap <silent> <a-y> "ty:call TmuxYank()<cr>
  vnoremap <silent> <a-d> "td:call TmuxYank()<cr>
else
  nnoremap <silent> <a-j> :wincmd j<cr>
  nnoremap <silent> <a-k> :wincmd k<cr>
  nnoremap <silent> <a-h> :wincmd h<cr>
  nnoremap <silent> <a-l> :wincmd l<cr>
  nnoremap <silent> <a-down> :wincmd j<cr>
  nnoremap <silent> <a-up> :wincmd k<cr>
  nnoremap <silent> <a-left> :wincmd h<cr>
  nnoremap <silent> <a-right> :wincmd l<cr>
  inoremap <silent> <a-j> <esc>:wincmd j<cr>
  inoremap <silent> <a-k> <esc>:wincmd k<cr>
  inoremap <silent> <a-h> <esc>:wincmd h<cr>
  inoremap <silent> <a-l> <esc>:wincmd l<cr>
  inoremap <silent> <a-down> <esc>:wincmd j<cr>
  inoremap <silent> <a-up> <esc>:wincmd k<cr>
  inoremap <silent> <a-left> <esc>:wincmd h<cr>
  inoremap <silent> <a-right> <esc>:wincmd l<cr>
  vnoremap <silent> <a-j> <esc>:wincmd j<cr>
  vnoremap <silent> <a-k> <esc>:wincmd k<cr>
  vnoremap <silent> <a-h> <esc>:wincmd h<cr>
  vnoremap <silent> <a-l> <esc>:wincmd l<cr>
  vnoremap <silent> <a-down> <esc>:wincmd j<cr>
  vnoremap <silent> <a-up> <esc>:wincmd k<cr>
  vnoremap <silent> <a-left> <esc>:wincmd h<cr>
  vnoremap <silent> <a-right> <esc>:wincmd l<cr>
  nnoremap <silent> <a-p> "+p
  vnoremap <silent> <a-p> "+p
  vnoremap <silent> <a-y> "+y
  vnoremap <silent> <a-d> "+d
endif
" }}}
" Filetype settings {{{
augroup filetype_settings
  au!
  " Filetype detection {{{
  " my vimrc may not have the usual path
  au BufNewFile,BufRead $MYVIMRC setl filetype=vim
  au BufNewFile,BufRead *.vimp setl filetype=vim " vimperator files
  " tmux rc file
  au  BufNewFile,BufRead .tmux.conf,tmuxrc,site-tmuxrc setl filetype=tmux
  " html with mustaches
  au  BufNewFile,BufRead *.html.mustache,*.html.handlebars,*.html.hbs,*.html.hogan,*.html.hulk setl filetype=html.mustache
  " extra zsh files without extensions 
  au BufNewFile,BufRead $ZDOTDIR/functions/**/* setl filetype=zsh
  au BufNewFile,BufRead $ZDOTDIR/completion-functions/* setl filetype=zsh
  au BufNewFile,BufRead $ZDOTDIR/plugins/**/functions/* setl filetype=zsh
  " }}}
  " Vim {{{
  au FileType vim
        \   setl foldmethod=marker
        \ | setl foldenable
  " }}}
  " Zsh/sh {{{
  au FileType sh,bash,zsh setl noexpandtab
  au FileType zsh 
        \   runtime! indent/sh.vim
        \ | setl foldmethod=marker
        \ | setl foldenable
  " \ | setl listchars=tab:\ \ ,eol:¬,extends:❯,precedes:❮
  " }}}
  " Nasm {{{
  au FileType nasm 
        \   setl softtabstop=4
        \ | setl shiftwidth=4 
        \ | setl textwidth=150
  " }}}
  " Python {{{
  au FileType python 
        \   setl softtabstop=4
        \ | setl shiftwidth=4 
        \ | setl textwidth=79
  " }}}
augroup END

" }}}
" Appearance {{{
"
if has('gui_running') " gvim
  colorscheme molokai
  if g:is_windows
    set guifont=Ubuntu\ Mono:h16
  elseif has('win32unix') " cygwin
    set guifont=Consolas\ 16
  else
    set guifont=Ubuntu\ Mono\ 16,Inconsolata\ 16,Monospace\ 14
  endif
  set guioptions=
else

  if &term =~ 'tmux' || &term =~ 'rxvt-unicode-256color'
        \ || &term =~ 'xterm-256color'
    colorscheme twilight-term256
  endif

  if &term =~ 'tmux' || &term =~ 'rxvt-unicode-256color'
        \ || &term =~ 'xterm-256color-italic'
    " for tmux, this will only work if the client terminal supports italic
    " escape sequences
    highlight Comment cterm=italic
  endif

endif
" }}}
" Addons {{{
if !exists('g:vimrc_done_basic_init')
  let s:vim_addons = []
  " Slimux {{{
  if $TMUX != ''
    call add(s:vim_addons, 'github:epeli/slimux')
    nnoremap <silent> <f6> :SlimuxREPLSendLine<cr>
    inoremap <silent> <f6> <esc>:SlimuxREPLSendLine<cr>i
    vnoremap <silent> <f6> :SlimuxREPLSendSelection<cr>
  endif
  " }}}
  " CtrlP(fuzzy finder) {{{
  call add(s:vim_addons, 'github:kien/ctrlp.vim')
  set wildignore+=*.o,*.so,*.dll,*.exe,*.bak,*.swp,*.class,*.pyc,*.pyd,*.pyo,*~
  set wildignore+=*.zip,*.tgz,*.gz,*.bz2,*.lz,*.rar,*.7z,*.jar
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/](\.(git|hg|svn|bzr)|node_modules)$',
        \ }
  let g:ctrlp_extensions = ['tag']
  let g:ctrlp_cmd = 'Ctrlp'
  fun! s:search()
    SourceLocalVimrcOnce
    CtrlP
  endf
  command! Ctrlp call s:search()
  nnoremap <silent> <leader>p :CtrlPTag<CR>
  " }}}
  " Clang(C/C++) {{{
  " Disable auto popup, use <Tab> to autocomplete
  let g:clang_complete_auto = 0
  " Show clang errors in the quickfix window
  let g:clang_complete_copen = 1
  " Use clang library instead of the executable
  " This requires both libclang and its headers to be installed
  let g:clang_use_library = 1
  " clang integration
  call add(s:vim_addons, 'github:Rip-Rip/clang_complete')
  " }}}
  " NERDTree {{{
  call add(s:vim_addons, 'github:scrooloose/nerdtree')
  " close VIM if NERDTree is the only buffer left
  autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
  " toggle NERDTree
  nnoremap <silent> <F2> :NERDTreeToggle<CR>
  " }}}
  " SuperTab {{{
  call add(s:vim_addons, 'github:ervandew/supertab')
  " superTab option for context aware completion
  let g:SuperTabDefaultCompletionType = "context"
  " }}}
  " UltiSnips {{{
  if g:has_python
    let g:UltiSnipsEditSplit = 'normal'
    let g:UltiSnipsSnippetsDir = g:rc_dir . '/UltiSnips'
    if has('gui_running')
      let g:UltiSnipsListSnippets = '<c-tab>'
    else
      " terminal emulators must be configured to send [34~ when ctrl+tab is
      " pressed
      let g:UltiSnipsListSnippets = '<f20>'
    endif
    call add(s:vim_addons, 'github:SirVer/ultisnips')
  endif
  " }}}
  " Gundo {{{
  if g:has_python
    call add(s:vim_addons, 'github:sjl/gundo.vim.git')
    nnoremap <leader>u :GundoToggle<cr>
  endif
  " }}}
  " Typescript-vim {{{
  call add(s:vim_addons, 'github:leafgarland/typescript-vim')
  setl textwidth=80
  setl shiftwidth=2
  setl expandtab
  " }}}
  " Project-local vimrc {{{
  call add(s:vim_addons, 'github:MarcWeber/vim-addon-local-vimrc')
  let g:local_vimrc = {
        \ 'names': ['.lvimrc'],
        \ 'hash_fun': 'LVRHashOfFile'
        \ }
  " }}}
  " gnupg {{{
  let g:GPGPreferSymmetric = 1
  call add(s:vim_addons, 'github:jamessan/vim-gnupg.git')
  " }}}
  " Other {{{
  call add(s:vim_addons, 'github:Raimondi/delimitMate') " autoclose brackets,quotes...
  call add(s:vim_addons, 'github:tpope/vim-tbone')
  call add(s:vim_addons, 'github:tpope/vim-repeat')
  call add(s:vim_addons, 'github:tpope/vim-surround')
  call add(s:vim_addons, 'github:tpope/vim-fugitive')
  call add(s:vim_addons, 'github:tpope/vim-commentary')
  call add(s:vim_addons, 'github:juvenn/mustache.vim')
  call add(s:vim_addons, 'github:pangloss/vim-javascript')
  call add(s:vim_addons, 'github:kchmck/vim-coffee-script')
  call add(s:vim_addons, 'github:kelan/gyp.vim')
  call add(s:vim_addons, 'github:groenewege/vim-less')
  call add(s:vim_addons, 'github:danro/rename.vim')
  call add(s:vim_addons, 'github:mattn/webapi-vim')
  call add(s:vim_addons, 'github:mattn/gist-vim')
  call add(s:vim_addons, 'github:walm/jshint.vim')
  call add(s:vim_addons, 'github:vim-scripts/scratch.vim')
  call add(s:vim_addons, 'github:godlygeek/csapprox')
  call add(s:vim_addons, 'github:godlygeek/tabular.git')
  call add(s:vim_addons, 'github:mileszs/ack.vim')
  call add(s:vim_addons, 'github:PProvost/vim-ps1.git')
  " }}}
  " load 'after' directory
  let &runtimepath = &runtimepath.','.g:rc_dir.'/after'
  " }}} 
  " Package management(vim-addon-manager setup) {{{
  let g:vim_addon_manager = {}
  let g:vim_addon_manager.auto_install = 1
  let g:vim_addon_manager.log_to_buf = 1
  let g:vim_addon_manager.shell_commands_run_method = 'system'
  let g:vim_addon_manager.plugin_root_dir = g:vam_plugins_dir
  if !isdirectory(g:vim_addon_manager.plugin_root_dir)
    call mkdir(g:vim_addon_manager.plugin_root_dir, "p")
  endif
  if !isdirectory(g:vim_addon_manager.plugin_root_dir.'/vim-addon-manager/autoload')
    execute '!git clone git://github.com/MarcWeber/vim-addon-manager '
          \ shellescape(g:vim_addon_manager.plugin_root_dir.'/vim-addon-manager', 1)
  endif
  let g:vim_addon_manager.scms = {'scms': {}}
  if executable('git')
    fun! VamGitClone(repository, targetDir)
      return vam#utils#RunShell('git clone $.url $p', a:repository, a:targetDir)
    endfun
    let g:vim_addon_manager.scms.git = {'clone': ['VamGitClone']}
  else
    let g:vim_addon_manager.drop_git_sources = 1
  endif
  call vam#ActivateAddons(s:vim_addons)
  let g:vimrc_done_basic_init = 1
endif
" }}}
