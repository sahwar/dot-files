#!/usr/bin/env zsh

# Validate the installed tmux version
tmux_version=($(tmux -V 2> /dev/null))
if (( $#tmux_version == 0 )); then
	print 'tmux not found' >&2
	exit 1
fi
tmux_version=$tmux_version[2]
tmux_version=${${tmux_version}/\./}
if (( tmux_version < 17 )); then
	print 'tmux version must be at least 1.7' >&2
	exit 1
fi

program=$0
zmux_command=$1
session_name=$2
sessions_repository="$HOME/.tmux-sessions"
session_dir="$sessions_repository/$session_name"

zmodload zsh/zutil
zmodload -F zsh/stat b:zstat

pane() {
	local o_target o_detach o_dir args
	o_target=(-t $pane_id)
	# ignore 'detach' option to ensure we get the unique pane id with
	# display-message
	o_detach=(-d)
	o_print=(-P)
	o_format=(-F)
	o_dir=(-c $project_dir)
	zparseopts -D -K t:=o_target d:=o_detach c:=o_dir P:=o_print F:=o_format
	args=(-P -F '#{pane_id}' -t $o_target[2])
	if [[ -n $project_dir ]]; then
		args+=(-c $o_dir[2])
	fi
	pane_id=$(tmux split-window ${(z)args} "$@")
}

window() {
	local o_target o_detach o_dir args
	o_target=(-t '')
	o_detach=(-d)
	o_print=(-P)
	o_format=(-F)
	o_dir=(-c $project_dir)
	zparseopts -D -K t:=o_target d:=o_detach c:=o_dir P:=o_print F:=o_format

	if [[ -z $session_id ]]; then
		args=(-P -F '#{session_id}' -d -s $session_name)
		[[ -n $1 ]] && args+=(-n $1)

		if [[ -n $project_dir ]]; then
			project_dir=${~project_dir}
			session_id=$(cd $project_dir && TMUX= tmux new-session $args)
		 	tmux set-option -t $session_id -q default-path $project_dir
		else
			session_id=$(TMUX= tmux new-session $args)
		fi

		window_id=$(tmux display -p -t $session_id '#{window_id}')
		pane_id=$(tmux display -p -t $session_id '#{pane_id}')
		first_window_created=1
	else
		args=(-P -F '#{window_id}')
		[[ -n $1 ]] && args+=(-n $1)

		window_id=$(tmux new-window ${(z)args})
		pane_id=$(tmux display -p -t $session_id '#{pane_id}')
	fi
}

send() {
	local o_target
	o_target=(-t $pane_id)
	zparseopts -D -K t:=o_target
	tmux send-keys -t $o_target[2] "$@"
}

command() {
	local o_target
	o_target=(-t $pane_id)
	zparseopts -D -K t:=o_target
	send -t $o_target[2] -l "$@"
	send -t $o_target[2] "C-m"
}

set() {
	tmux set-option -t $session_id -q "@$1" $2
}

get() {
	tmux show-options -t $session_id -v "@$1" 2> /dev/null
}

function {
if [[ -z $zmux_command ]]; then
	print "Need a command" >&2
	exit 1
fi

if [[ -z $session_name && $zmux_command != (close|list|list-commands) ]]; then
	print "Need a session name" >&2
	exit 1
fi

local session_open="$session_dir/tmux-open.zsh"
local session_close="$session_dir/tmux-close.zsh"
local session_open_template session_close_template

read -d '' -r session_open_template << "EOF"
# Basic session template for developing a project with vim as the editor. 

# If you want the session to have a default directory, set the project_dir
# variable first
# project_dir="~/project"

# Rename the first window to 'editor'
window editor

# Create a pane at the bottom with 75% of window height. This pane will
# be running vim
pane -p 75

# Vim has a session persistence system, initialize vim with a command to
# persist the session in the session directory
vim_session_file="$session_dir/session.vim"
vim_session_file="${(q)vim_session_file}"
setup_cmd="mksession! ${vim_session_file}"

# If the vim session file exists, load the session instead of saving
if [[ -e $vim_session_file ]]; then
	setup_cmd="so ${vim_session_file}"
fi

# When vim exits, save the session back to the file
teardown_cmd="au VimLeavePre * mksession! ${vim_session_file}"

command "vim -c '${setup_cmd}' -c '${teardown_cmd}'"

# Save the vim pane id into the tmux session. This will be used
# to gracefully shutdown vim later
set vim-pane $pane_id
EOF

read -d '' -r session_close_template << "EOF"
# Put any cleanup commands here to gracefully shutdown your sessions
# when 'zmux close' is called.

# get the vim pane id
vim_pane_id=$(get vim-pane)

# send escape to ensure vim is in normal mode
send -t $vim_pane_id "Escape"

# write all buffers and quit vim
command -t $vim_pane_id ":wqa"
EOF

[[ -z $EDITOR ]] && EDITOR=vi

case $zmux_command in
	open)
		if [[ ! -r "$session_dir/" ]]; then
			print "Session '$session_name' isn't registered" >&2
			exit 1
		fi
		if [[ ! -r $session_open ]]; then
			print "Session '$session_name' has no script" >&2
			exit 1
		fi
		if ! tmux has-session -t $session_name &> /dev/null; then
			source $session_open
		fi
		if [[ -z $TMUX ]]; then
			tmux attach-session -t $session_name
		else
			tmux switch-client -t $session_name
		fi
		;;
	close)
		if [[ -z $session_name ]]; then
			sessions=($($program list))
		else
			sessions=($session_name)
		fi
		for session_name in $sessions; do
			session_dir="$sessions_repository/$session_name"
			session_close="$session_dir/tmux-close.zsh"
			if tmux has-session -t $session_name; then
				if [[ -r $session_close ]]; then
					# For consistency with setup scripts, populate {session,window,pane}_id
					# variables
					session_id=$(tmux display -p -t $session_name '#{session_id}')
					window_id=$(tmux display -p -t $session_id '#{window_id}')
					pane_id=$(tmux display -p -t $session_id '#{pane_id}')
					source $session_close
				fi
				# Apparently tmux processes one command at a time, so before processing
				# 'kill-session' it will process any 'send-keys' commands from the
				# cleanup scripts
				tmux kill-session -t $session_name
				print "Session '$session_name' closed successfully"
			fi
		done
		;;
	list)
		sessions="$sessions_repository/*(/N:t)"
		for session in ${~sessions}; do
			print $session
		done
		;;
	list-commands)
		for cmd in open close list list-commands new rm edit edit-close; do
			print $cmd
		done
		;;
	new)
		[[ -d $session_dir ]] && print 'Session already exists' >&2 && exit 1
		tmpfile="/tmp/zmux-session-open-$RANDOM-$$.zsh"
		print $session_open_template > $tmpfile
		mtime=$(zstat +mtime $tmpfile)
		$EDITOR $tmpfile
		if (( mtime != $(zstat +mtime $tmpfile) )); then
			# only create the session if the temporary file was modified
			if ! mkdir -m 700 $session_dir; then
				rm $tmpfile
				print 'Failed to create session directory' >&2 &&	exit 1
			fi
			mv $tmpfile $session_open
			print "Session '$session_name' created successfully"
		else
			print "Session '$session_name' was not created" >&2
			exit 1
		fi
		;;
	rm)
		if [[ ! -d $session_dir ]]; then
			print "Session '$session_name' doesn't exist" >&2
			exit 1
		fi
		read -q "REPLY?Are you sure you want to remove '$session_name'? "
		if [[ $REPLY == y ]]; then
			rm -rf $session_dir
			print "\nSession '$session_name' removed successfully"
		else
			print "\nSession '$session_name' not removed"
			exit 1
		fi
		;;
	edit|edit-close)
		if [[ ! -r $session_open ]]; then
			print "Session '$session_name' isn't registered" >&2
			exit 1
		fi
		if [[ ! -r $session_open ]]; then
			print "Session '$session_name' has no script" >&2
			exit 1
		fi
		if [[ $zmux_command == "edit-close" ]]; then
			if [[ -r $session_close ]]; then
				$EDITOR $session_close
			else
				tmpfile="/tmp/zmux-session-close-$RANDOM-$$.zsh"
				print $session_close_template > $tmpfile
				mtime=$(zstat +mtime $tmpfile)
				$EDITOR $tmpfile
				if (( mtime != $(zstat +mtime $tmpfile ) )); then
					mv $tmpfile $session_close
					print "Teardown script for '$session_name' created successfully"
				else
					print "Teardown script for '$session_name' was not created"
					exit 1
				fi
			fi
		else
			$EDITOR $session_open
		fi
		;;
	*)
		print "Invalid command" >&2
		;;
esac
}
